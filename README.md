<p align="center">
  <img alt="Pelando" height="64" src="./public/favicons/favicon.svg">
</p>

<h1 align="center">Client Web</h1>

<div align="center">
  Front-end project for Pelando.com.br website.
</div>

## URLs

Local: [http://localhost:3203](http://localhost:3203)

Development: [web.development.pelandolabs.com.br](https://web.development.pelandolabs.com.br)

## Prerequisite

Start at [Confluence](https://pelandobr.atlassian.net/l/c/wXKFtYce)

## Dev Usage

1. Clone project code:

```bash
git clone git@github.com:pelando/client-web.git
cd client-web
```

2. [Download](https://docs.google.com/document/d/1bwp1U7E3zBj1BlcY3-tTF0HKoQ4cicPzP2Ftt9LqxvY/edit#) the development `.env` file for this repository.

3. Install project dependencies:

```bash
  yarn install
```

4. Start the build process in watch mode:

> <small>This will build both the express server for the SSR as well as the client's code!</small>

```bash
   yarn build:watch
```

5. When the first build is done, run the server on another terminal:

> <small>You will see all the created files on the terminal output when the build finishes</small>

```
  yarn start:dev
```

> <small>‚ö†Ô∏è Both the build and the server will be watching your files for changes but there is no Hot Module Replacement or Live reload, so make sure that you refresh your browser.</small>

6. Open a browser and visit [http://localhost:3203](http://localhost:3203).

7. Stop the applications with:

```bash
ctrl + c
```

## Dev Usage (Docker)

To develop using docker all you have to do is:

```bash
make up
```

üí° It is highly recommended to use docker since it is closer to what is executed on our production environments. It will also make you get in touch with a widely used tool in the industry :)

## Production build

> You may check the full build process that is present on the `.circleci/config.yml` file for detailed step by step.

In order to get a production-ready build you must set `NODE_ENV=production` and make sure that all the other environment variables have appropriate values so double-check your `.env` file. So basically:

```bash
NODE_ENV=production yarn build
```

Will give you a production ready build under the `dist` folder that you can use to test without all the development dependencies with `node dist/server`.

For a complete build artifact that has all dependencies included:

```bash
docker-compose -f docker-compose.ci.yml build
```

## SVG

### Optimization

Optimize single-path SVGs in packages/resources/icons

```
yarn optimize:icons
```

Optimize multi-path SVGs in packages/resources/graphics

```
yarn optimize:graphics
```

### Sprites

To take advantage of our SVG [sprite file](<https://en.wikipedia.org/wiki/Sprite_(computer_graphics)>), save the icon with `.sprite.svg` extension.

Usage example:

```tsx
// icon file:
packages / resources / icons / navigation / deal - filled - add.sprite.svg;
```

```tsx
// import:
import AddOfferFilledIcon from '@client-web/resources/icons/navigation/deal-filled-add.sprite.svg';
```

Use `AddOfferFilledIcon.url` as the value of `xlinkHref` SVG attribute.

:warning: It should only be used with SVG without complex rules or filters.

## Other commands

Run unit tests:

```bash
yarn test
```

Run linters:

```bash
yarn lint
```

Run storybook:

```bash
yarn storybook
```

Start server for SSR:

```bash
yarn start:ssr-dev
```

Update schema from Apollo

```
yarn apollo:schema
```

Generate types from queries and schema

```
yarn apollo:codegen
```

Generate types from queries and schema (watch mode)

```
yarn apollo:codegen --watch
```

Analyzes the generated bundle

```
yarn build:analyzer
```

> <small> üí° This will open a page you can use to inspect what is included in each chunk generated by webpack. It is quite neat to check when searching for performance opportunities! There are some content to help in this optimizations:
>
> - [Bundle analysis](https://survivejs.com/webpack/optimizing/build-analysis/);
> - [Code Splitting](https://loadable-components.com/docs/code-splitting/)</small>

## Container commands (you need to raise the container with make up)

Start shell inside container

```bash
make shell
```

## Debugging parameters

Add these query string parameters to the url for debugging purposes:

- `debug_hydrate=never` to disable React hydration completely
- `debug_hydrate=immediate` to force immediate React hydration instead of waiting for user interaction
- `debug_disable_sentry=1` to disable Sentry initialization
- `debug_disable_sw=1` to disable Service Worker installation
- `debug_disable_scripts=1` to disable script tags injection on the server

## Jest and Client-environment differences

**Processing files**

As we have the webpack's loaders to deal with non-JavaScript files (or non-supported JS files in it's current Node's environment), we also need this kind of dealing process to Jest's environment and that cames with the [`transform`](https://jestjs.io/docs/configuration#transform-objectstring-pathtotransformer--pathtotransformer-object) and [`moduleNameMapper`](https://jestjs.io/docs/configuration#modulenamemapper-objectstring-string--arraystring) (in Jest config).

One example is the _transform_ `"^.+\\.(js|jsx|ts|tsx)$": "babel-jest"`, that transpiles TypeScript code (thanks to `@babel/preset-typescript` and `tsconfig.json` file). So, there's no use of webpack but Jest does need some tool to deal with this kind of files.

**Globals and DOM APIs**

Another point is: there are no JS downloaded by a `<script>` tag when a test is running. In a browser, it is common to use some script tags to download and use third-party code. As we use some of this thing in this code-base, it is necessary to set the globals to Jest undestands that there are some global stuff. It can be done by [`globals` option](https://jestjs.io/docs/configuration#globals-object).

Also, may be some browser/DOM APIs that JSDOM (the DOM implementation used by Jest) hasn't implemented yet, or some APIs that we need a specific behavior, so we need to mock that stuff. Here is some related content:

- [Mocking methods which are not implemented in JSDOM](https://jestjs.io/docs/manual-mocks#mocking-methods-which-are-not-implemented-in-jsdom)
- [`jest.spyOn`](https://jestjs.io/docs/jest-object#jestspyonobject-methodname)
